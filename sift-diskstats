#!/bin/bash
# This program is part of Aspersa (http://code.google.com/p/aspersa/)

# ########################################################################
# This script reads a file that was generated from /proc/diskstats and
# summarizes it, kind of like iostat.  The file should look like this:
#
# TS <timestamp>
# <contents of /proc/diskstats>
# TS <timestamp>
# <contents of /proc/diskstats>
# ... et cetera
# TS <timestamp>  <-- must end with a TS line.
#
# It has three modes:
# 1) show summary stats over the entire interval for each disk (default).
# 2) show summary stats for each sample in the interval, for all disks.
# 3) show differential stats for specified disks for each sample.
#
# Author: Baron Schwartz
# ########################################################################

# Prints out one line for each disk, summing over the interval from first to
# last sample.  Arguments: $1 = filename to read.
sum_group_by_disk () {
   awk '
   $1 !~ /^TS / {

      # The entries in each stat line are as follows:
      #   1	major
      #   2	minor
      #   3	device name
      dev = $3;
      #   4	reads
      reads = $4;
      #   5	reads merged
      reads_merged = $5;
      #   6	read sectors
      read_sectors = $6;
      #   7	ms spent reading
      ms_spent_reading = $7;
      #   8	writes
      writes = $8;
      #   9	writes merged
      writes_merged = $9;
      #  10	written sectors
      written_sectors = $10;
      #  11	ms spent writing
      ms_spent_writing = $11;
      #  12	IOs in progress
      ios_in_progress = $12;
      #  13	ms spent doing io
      ms_spent_doing_io = $13;
      #  14	ms spent, weighted by ios_in_progress
      ms_weighted = $14;

      # Keep track of the natural order of the devices, so we can print them out
      # nicely later; and also keep the first-ever line of output.  This only
      # executes the first time through.
      devices[dev]++;
      if ( devices[dev] == 1 ) {
         devsort[devs++] = dev;
         first["ts"]                     = ts;
         first[dev "_reads"]             = reads;
         first[dev "_reads_merged"]      = reads_merged;
         first[dev "_read_sectors"]      = read_sectors;
         first[dev "_ms_spent_reading"]  = ms_spent_reading;
         first[dev "_writes"]            = writes;
         first[dev "_writes_merged"]     = writes_merged;
         first[dev "_written_sectors"]   = written_sectors;
         first[dev "_ms_spent_writing"]  = ms_spent_writing;
         first[dev "_ios_in_progress"]   = ios_in_progress;
         first[dev "_ms_spent_doing_io"] = ms_spent_doing_io;
         first[dev "_ms_weighted"]       = ms_weighted;
      }

      curr[dev "_reads"]             = reads;
      curr[dev "_reads_merged"]      = reads_merged;
      curr[dev "_read_sectors"]      = read_sectors;
      curr[dev "_ms_spent_reading"]  = ms_spent_reading;
      curr[dev "_writes"]            = writes;
      curr[dev "_writes_merged"]     = writes_merged;
      curr[dev "_written_sectors"]   = written_sectors;
      curr[dev "_ms_spent_writing"]  = ms_spent_writing;
      curr[dev "_ios_in_progress"]   = ios_in_progress;
      curr[dev "_ms_spent_doing_io"] = ms_spent_doing_io;
      curr[dev "_ms_weighted"]       = ms_weighted;

   }
   $1 ~ /^TS/ {
      # Compute statistics, if there are any.
      if ( iterations > 1 ) {
         # XXX Do computations here.
      }
      # Last step: save the current stats as prev.
      if ( iterations > 0 ) {
         curr["ts"] = ts;
         for (i in curr) {
            prev[i] = curr[i];
         }
      }
      ts = $2;
      iterations++;
   }
   END {
      # First, figure out the max length of any device name (or the header).
      mdev = 7;
      for ( i = 1; i < devs; i++ ) {
         dlen = length(devsort[i]);
         if ( dlen > mdev ) {
            mdev = dlen;
         }
      }

      # For each device, print out the following:
      # The timestamp offset and device name
      fmt = "%5s %-" mdev "s";
      hdr = fmt;
      # The per-second reads, read size (kB), per-second MB read, read merged pct, read
      # concurrency, and average response time for each read.
      fmt = fmt " %7.1f %7.1f %7.1f %5.0f%% %6.1f %7.1f";
      hdr = hdr " %7s %7s %7s %6s %6s %7s";
      # The same for writes.
      fmt = fmt " %7.1f %7.1f %7.1f %5.0f%% %6.1f %7.1f";
      hdr = hdr " %7s %7s %7s %6s %6s %7s";
      # Then active%, in-progress, and line-ending.
      fmt = fmt " %3.0f%% %6d\n";
      hdr = hdr " %4s %6s\n";
      printf(hdr, "#ts", "device",
         "rd_s", "rd_avkb", "rd_mb_s", "rd_mrg", "rd_cnc", "rd_rt",
         "wr_s", "wr_avkb", "wr_mb_s", "wr_mrg", "wr_cnc", "wr_rt",
         "act%", "in_prg");

      for ( i = 1; i < devs; i++ ) {
         dev               = devsort[i];

         # Get incremental numbers.
         elapsed           = curr["ts"]                     - first["ts"];
         reads             = curr[dev "_reads"]             - first[dev "_reads"];
         reads_merged      = curr[dev "_reads_merged"]      - first[dev "_reads_merged"];
         read_sectors      = curr[dev "_read_sectors"]      - first[dev "_read_sectors"];
         ms_spent_reading  = curr[dev "_ms_spent_reading"]  - first[dev "_ms_spent_reading"];
         writes            = curr[dev "_writes"]            - first[dev "_writes"];
         writes_merged     = curr[dev "_writes_merged"]     - first[dev "_writes_merged"];
         written_sectors   = curr[dev "_written_sectors"]   - first[dev "_written_sectors"];
         ms_spent_writing  = curr[dev "_ms_spent_writing"]  - first[dev "_ms_spent_writing"];
         ms_spent_doing_io = curr[dev "_ms_spent_doing_io"] - first[dev "_ms_spent_doing_io"];
         ms_weighted       = curr[dev "_ms_weighted"]       - first[dev "_ms_weighted"];

         # Compute the per-second stats for reads.
         reads_sec        = reads/elapsed;
         read_requests    = reads_merged + reads;
         mbytes_read_sec  = read_sectors / elapsed / 2048;
         read_conc        = ms_spent_reading / elapsed / 1000;
         if ( reads > 0 ) {
            read_rtime    = ms_spent_reading / reads;
            avg_read_sz   = read_sectors / reads / 2;
         }
         else {
            read_rtime    = 0;
            avg_read_sz   = 0;
         }
         if ( read_requests > 0 ) {
            read_merge_pct = 100 * reads_merged / read_requests;
         }
         else {
            read_merge_pct = 0;
         }

         # Compute the per-second stats for writes.
         writes_sec          = writes/elapsed;
         write_requests      = writes_merged + writes;
         mbytes_written_sec  = written_sectors / elapsed / 2048;
         write_conc          = ms_spent_writing / elapsed / 1000;
         if ( writes > 0 ) {
            write_rtime      = ms_spent_writing / writes;
            avg_write_sz     = written_sectors / writes / 2;
         }
         else {
            write_rtime      = 0;
            avg_write_sz     = 0;
         }
         if ( write_requests > 0 ) {
            write_merge_pct = 100 * writes_merged / write_requests;
         }
         else {
            write_merge_pct = 0;
         }

         # Compute the numbers for reads and writes together, the things for
         # which we do not have separate statistics.

         # "Active" is what iostat calls %util.  This is the percent of
         # wall-clock time during which the device has I/O happening.
         active = 100 * ms_spent_doing_io / (1000 * elapsed);

         # This is simply the number of requests currently in progress.
         in_progress = curr[dev "_ios_in_progress"];

         printf(fmt, "all", dev,
            reads_sec,  avg_read_sz,  mbytes_read_sec,    read_merge_pct,  read_conc,  read_rtime,
            writes_sec, avg_write_sz, mbytes_written_sec, write_merge_pct, write_conc, write_rtime,
            active, in_progress);
      }
   }
   ' "$1"
}

# Prints out one line for each sample, summing up all disks together.
# Arguments: $1 = filename to read.
group_by_sample() {
   awk '
   ' "$1"
}

# disks=$(awk '$1 ~ /^[0-9]/{print $3}' "$1" | sort -u);
sum_group_by_disk "$1";
#group_by_sample "$1";
