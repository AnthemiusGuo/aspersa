#!/bin/bash
# This program is part of Aspersa (http://code.google.com/p/aspersa/)

# ########################################################################
# This script reads a file that was generated from /proc/diskstats and
# summarizes it, kind of like iostat.  The file should look like this:
#
# TS <timestamp>
# <contents of /proc/diskstats>
# TS <timestamp>
# <contents of /proc/diskstats>
# ... et cetera
# TS <timestamp>  <-- must end with a TS line.
#
# It has three modes:
# 1) show summary stats over the entire interval for each disk (default).
# 2) show summary stats for each sample in the interval, for all disks.
# 3) show differential stats for specified disks for each sample.
#
# Author: Baron Schwartz
# ########################################################################

# A bunch of snippets of awk code, to be reused in the functions below.
awk_parse_line="
      # The entries in each stat line are as follows:
      #   1	major
      #   2	minor
      #   3	device name
      dev = \$3;
      #   4	reads
      reads = \$4;
      #   5	reads merged
      reads_merged = \$5;
      #   6	read sectors
      read_sectors = \$6;
      #   7	ms spent reading
      ms_spent_reading = \$7;
      #   8	writes
      writes = \$8;
      #   9	writes merged
      writes_merged = \$9;
      #  10	written sectors
      written_sectors = \$10;
      #  11	ms spent writing
      ms_spent_writing = \$11;
      #  12	IOs in progress
      ios_in_progress = \$12;
      #  13	ms spent doing io
      ms_spent_doing_io = \$13;
      #  14	ms spent, weighted by ios_in_progress
      ms_weighted = \$14;
"

# NOTE: this one is necessary in order to get the device listing.
awk_get_first_sample="
      # Keep track of the natural order of the devices, so we can print them out
      # nicely later; and also keep the first-ever line of output.  This only
      # executes the first time through.
      devices[dev]++;
      if ( devices[dev] == 1 ) {
         devsort[devs++] = dev;
         first[\"ts\"]                     = ts;
         first[dev \"_reads\"]             = reads;
         first[dev \"_reads_merged\"]      = reads_merged;
         first[dev \"_read_sectors\"]      = read_sectors;
         first[dev \"_ms_spent_reading\"]  = ms_spent_reading;
         first[dev \"_writes\"]            = writes;
         first[dev \"_writes_merged\"]     = writes_merged;
         first[dev \"_written_sectors\"]   = written_sectors;
         first[dev \"_ms_spent_writing\"]  = ms_spent_writing;
         first[dev \"_ios_in_progress\"]   = ios_in_progress;
         first[dev \"_ms_spent_doing_io\"] = ms_spent_doing_io;
         first[dev \"_ms_weighted\"]       = ms_weighted;
      }
"

awk_get_curr_sample="
      curr[dev \"_reads\"]             = reads;
      curr[dev \"_reads_merged\"]      = reads_merged;
      curr[dev \"_read_sectors\"]      = read_sectors;
      curr[dev \"_ms_spent_reading\"]  = ms_spent_reading;
      curr[dev \"_writes\"]            = writes;
      curr[dev \"_writes_merged\"]     = writes_merged;
      curr[dev \"_written_sectors\"]   = written_sectors;
      curr[dev \"_ms_spent_writing\"]  = ms_spent_writing;
      curr[dev \"_ios_in_progress\"]   = ios_in_progress;
      curr[dev \"_ms_spent_doing_io\"] = ms_spent_doing_io;
      curr[dev \"_ms_weighted\"]       = ms_weighted;
"

awk_save_curr_as_prev="
      # Last step: save the current stats as prev.
      if ( iterations > 0 ) {
         curr[\"ts\"] = ts;
         for (i in curr) {
            prev[i] = curr[i];
         }
      }
      ts = \$2;
"

awk_find_max_device_name_length="
      mdev = 6;
      for ( i = 0; i < devs; i++ ) {
         dlen = length(devsort[i]);
         if ( dlen > mdev ) {
            mdev = dlen;
         }
      }
"

awk_design_printf_formats="
      # For each device, print out the following:
      # The timestamp offset and device name
      fmt = \"%5s %-\" mdev \"s\";
      hdr = fmt;
      # The per-second reads, read size (kB), per-second MB read, read merged pct, read
      # concurrency, and average response time for each read.
      fmt = fmt \" %7.1f %7.1f %7.1f %5.0f%% %6.1f %7.1f\";
      hdr = hdr \" %7s %7s %7s %6s %6s %7s\";
      # The same for writes.
      fmt = fmt \" %7.1f %7.1f %7.1f %5.0f%% %6.1f %7.1f\";
      hdr = hdr \" %7s %7s %7s %6s %6s %7s\";
      # Then active%, in-progress, and line-ending.
      fmt = fmt \" %3.0f%% %6d\\n\";
      hdr = hdr \" %4s %6s\\n\";
"

awk_print_header="
      printf(hdr, \"#ts\", \"device\",
         \"rd_s\", \"rd_avkb\", \"rd_mb_s\", \"rd_mrg\", \"rd_cnc\", \"rd_rt\",
         \"wr_s\", \"wr_avkb\", \"wr_mb_s\", \"wr_mrg\", \"wr_cnc\", \"wr_rt\",
         \"act%\", \"in_prg\");
"

awk_get_overall_increments="
         # Get incremental numbers.
         elapsed           = curr[\"ts\"]                     - first[\"ts\"];
         reads             = curr[dev \"_reads\"]             - first[dev \"_reads\"];
         reads_merged      = curr[dev \"_reads_merged\"]      - first[dev \"_reads_merged\"];
         read_sectors      = curr[dev \"_read_sectors\"]      - first[dev \"_read_sectors\"];
         ms_spent_reading  = curr[dev \"_ms_spent_reading\"]  - first[dev \"_ms_spent_reading\"];
         writes            = curr[dev \"_writes\"]            - first[dev \"_writes\"];
         writes_merged     = curr[dev \"_writes_merged\"]     - first[dev \"_writes_merged\"];
         written_sectors   = curr[dev \"_written_sectors\"]   - first[dev \"_written_sectors\"];
         ms_spent_writing  = curr[dev \"_ms_spent_writing\"]  - first[dev \"_ms_spent_writing\"];
         ms_spent_doing_io = curr[dev \"_ms_spent_doing_io\"] - first[dev \"_ms_spent_doing_io\"];
         ms_weighted       = curr[dev \"_ms_weighted\"]       - first[dev \"_ms_weighted\"];
         in_progress       = curr[dev \"_ios_in_progress\"];
"

awk_get_current_increments="
         # Get incremental numbers.
         elapsed           = ts                               - prev[\"ts\"];
         reads             = curr[dev \"_reads\"]             - prev[dev \"_reads\"];
         reads_merged      = curr[dev \"_reads_merged\"]      - prev[dev \"_reads_merged\"];
         read_sectors      = curr[dev \"_read_sectors\"]      - prev[dev \"_read_sectors\"];
         ms_spent_reading  = curr[dev \"_ms_spent_reading\"]  - prev[dev \"_ms_spent_reading\"];
         writes            = curr[dev \"_writes\"]            - prev[dev \"_writes\"];
         writes_merged     = curr[dev \"_writes_merged\"]     - prev[dev \"_writes_merged\"];
         written_sectors   = curr[dev \"_written_sectors\"]   - prev[dev \"_written_sectors\"];
         ms_spent_writing  = curr[dev \"_ms_spent_writing\"]  - prev[dev \"_ms_spent_writing\"];
         ms_spent_doing_io = curr[dev \"_ms_spent_doing_io\"] - prev[dev \"_ms_spent_doing_io\"];
         ms_weighted       = curr[dev \"_ms_weighted\"]       - prev[dev \"_ms_weighted\"];
         in_progress       = curr[dev \"_ios_in_progress\"];
"

awk_reset_variables="
         t_reads             = 0;
         t_reads_merged      = 0;
         t_read_sectors      = 0;
         t_ms_spent_reading  = 0;
         t_writes            = 0;
         t_writes_merged     = 0;
         t_written_sectors   = 0;
         t_ms_spent_writing  = 0;
         t_ms_spent_doing_io = 0;
         t_ms_weighted       = 0;
         t_in_progress       = 0;
"

awk_compute_sums_group_by_disk="
         t_reads             = reads;
         t_reads_merged      = reads_merged;
         t_read_sectors      = read_sectors;
         t_ms_spent_reading  = ms_spent_reading;
         t_writes            = writes;
         t_writes_merged     = writes_merged;
         t_written_sectors   = written_sectors;
         t_ms_spent_writing  = ms_spent_writing;
         t_ms_spent_doing_io = ms_spent_doing_io;
         t_ms_weighted       = ms_weighted;
         t_in_progress       = in_progress;
"

awk_compute_sums_group_by_sample="
         t_reads             += reads;
         t_reads_merged      += reads_merged;
         t_read_sectors      += read_sectors;
         t_ms_spent_reading  += ms_spent_reading;
         t_writes            += writes;
         t_writes_merged     += writes_merged;
         t_written_sectors   += written_sectors;
         t_ms_spent_writing  += ms_spent_writing;
         t_ms_spent_doing_io += ms_spent_doing_io;
         t_ms_weighted       += ms_weighted;
         t_in_progress       += in_progress;
"

awk_compute_read_write_stats="
         # Compute the per-second stats for reads, writes, and overall.
         reads_sec        = t_reads / elapsed;
         read_requests    = t_reads_merged + t_reads;
         mbytes_read_sec  = t_read_sectors / elapsed / 2048;
         read_conc        = t_ms_spent_reading / elapsed / 1000 / ndevs;
         if ( t_reads > 0 ) {
            read_rtime    = t_ms_spent_reading / t_reads;
            avg_read_sz   = t_read_sectors / t_reads / 2;
         }
         else {
            read_rtime    = 0;
            avg_read_sz   = 0;
         }
         if ( read_requests > 0 ) {
            read_merge_pct = 100 * t_reads_merged / read_requests;
         }
         else {
            read_merge_pct = 0;
         }
         writes_sec          = t_writes / elapsed;
         write_requests      = t_writes_merged + t_writes;
         mbytes_written_sec  = t_written_sectors / elapsed / 2048;
         write_conc          = t_ms_spent_writing / elapsed / 1000 / ndevs;
         if ( t_writes > 0 ) {
            write_rtime      = t_ms_spent_writing / t_writes;
            avg_write_sz     = t_written_sectors / t_writes / 2;
         }
         else {
            write_rtime      = 0;
            avg_write_sz     = 0;
         }
         if ( write_requests > 0 ) {
            write_merge_pct = 100 * t_writes_merged / write_requests;
         }
         else {
            write_merge_pct = 0;
         }
         # Compute the numbers for reads and writes together, the things for
         # which we do not have separate statistics.
         # \"Active\" is what iostat calls %util.  This is the percent of
         # wall-clock time during which the device has I/O happening.
         active = 100 * t_ms_spent_doing_io / (1000 * elapsed * ndevs);
"

awk_print_line="
         printf(fmt, line_ts, dev,
            reads_sec,  avg_read_sz,  mbytes_read_sec,    read_merge_pct,  read_conc,  read_rtime,
            writes_sec, avg_write_sz, mbytes_written_sec, write_merge_pct, write_conc, write_rtime,
            active, t_in_progress);
"

# Prints out one line for each disk, summing over the interval from first to
# last sample.  Arguments: $1 = filename to read.
group_by_disk () {
   cat > /tmp/aspersa <<EOF
   \$1 !~ /^TS / {
      ${awk_parse_line}
      ${awk_get_first_sample}
      ${awk_get_curr_sample}
   }
   \$1 ~ /^TS/ {
      ${awk_save_curr_as_prev}
      iterations++;
   }
   END {
      mdev = 6;
      ${awk_find_max_device_name_length}
      ${awk_design_printf_formats}
      ${awk_print_header}
      ndevs = 1;
      for ( i = 1; i < devs; i++ ) {
         dev               = devsort[i];
         ${awk_get_overall_increments}
         ${awk_compute_sums_group_by_disk}
         ${awk_compute_read_write_stats}
         line_ts="---";
         ${awk_print_line}
      }
   }
EOF
   awk -f /tmp/aspersa "$1"
}

# Prints out one line for each sample, summing up all disks together.
# Arguments: $1 = filename to read.
group_by_sample() {
   cat > /tmp/aspersa <<EOF
   BEGIN {
      mdev = 6;
      ${awk_design_printf_formats}
      ${awk_print_header}
   }
   \$1 !~ /^TS / {
      ${awk_parse_line}
      ${awk_get_first_sample}
      ${awk_get_curr_sample}
   }
   \$1 ~ /^TS/ {
      if ( iterations > 1 ) {
         ${awk_reset_variables}
         ndevs = devs;
         for ( i = 1; i < devs; i++ ) {
            dev               = devsort[i];
            ${awk_get_current_increments}
            ${awk_compute_sums_group_by_sample}
         }
         ${awk_compute_read_write_stats}
         line_ts = sprintf("%5.1f", ts - first["ts"]);
         dev     = "<" devs ">";
         ${awk_print_line}
      }
      ${awk_save_curr_as_prev}
      iterations++;
   }
EOF
   awk -f /tmp/aspersa "$1"
}

# Prints out one line for each sample, for each disk that matches the pattern.
# Arguments: $1 = filename to read, $2 = which disks to match.
group_by_all () {
   cat > /tmp/aspersa <<EOF
   \$1 !~ /^TS / && \$3 ~ /$2/ {
      ${awk_parse_line}
      ${awk_get_first_sample}
      ${awk_get_curr_sample}
   }
   \$1 ~ /^TS/ {
      if ( iterations > 0 ) {
         ${awk_find_max_device_name_length}
         ${awk_design_printf_formats}
      }
      if ( iterations > 1 ) {
         if ( devs > 1 || iterations == 2 ) {
            ${awk_print_header}
         }
         ${awk_reset_variables}
         ndevs = 1;
         line_ts = sprintf("%5.1f", ts - first["ts"]);
         for ( i = 0; i < devs; i++ ) {
            dev               = devsort[i];
            ${awk_get_current_increments}
            ${awk_compute_sums_group_by_disk}
            ${awk_compute_read_write_stats}
            ${awk_print_line}
         }
      }
      ${awk_save_curr_as_prev}
      iterations++;
   }
EOF
   awk -f /tmp/aspersa "$1"
}

# The main code that runs by default.  Arguments (command-line options) are the
# filename to read, the mode, and the devices to match.  All of them are
# optional.
# - If no argument is given, then it starts a loop, reading /proc/diskstats
#   once per second and displaying the output in "group_by_sample" mode.
# - If a filename/mode/pattern is given, and it is run interactively, then it
#   starts a loop and lets you control it until you exit with <Return>.
# - If not interactive, then it just runs once in the specified mode.
#
# Within the interactive loop, it runs and then reads a line.  A line can be one
# of the following:
# - empty line                quits the program
# - mode  <disk|sample|all>   sets the mode to group_by_${mode}
# - disk  <pattern>           filters on device name; pattern is an awk regexp
# - pager <program>           pipes output through the pager
main() {
   file="$1"
   mode="$2"
   disk="$3"
   iter=0;
   while true; do
      case "${mode}" in
         disk|sample|all)
            group_by_${mode} "${file}" "${disk}"
            ;;
         *)
            if [ "${iter}" = "0" ]; then
               echo "Usage: $0 <file> <mode> <pattern>"
               echo "          file: a file containing saved diskstats"
               echo "          mode: one of <disk|sample|all>"
               echo "       pattern: an awk regex to match disk names"
               exit
            fi
            echo "Sorry, I don't know what mode you mean.  Try <disk|sample|all>."
            ;;
      esac

      # Don't be "interactive" unless the user actually has control.
      if [ ! -t 0 -o ! -t 1 ]; then
         exit;
      fi

      while read cmd arg junk; do
         [ -z "${cmd}" ] && exit;
         case "${cmd}" in
            mode)
               mode="${arg}"
               break;
               ;;
            disk)
               disk="${arg}"
               break;
               ;;
            pager)
               echo "Pager isn't implemented yet, sorry."
               ;;
            q*)
               exit
               ;;
            *)
               echo "Sorry, that's not a known command.  Try mode|disk|pager"
               ;;
         esac
      done
      iter=$((iter + 1));
   done
}

# Execute the program if it was not included from another file.  This makes it
# possible to include without executing, and thus test.
if [ $(basename "$0") = "diskstats" ] || [ $(basename "$0") = "bash" ]; then
    main $*
fi
