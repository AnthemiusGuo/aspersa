#!/usr/bin/env bash
# This program is part of Aspersa (http://code.google.com/p/aspersa/)

# ########################################################################
# A script to collect information from a server for some period of time.
# Focused on gathering diagnostic data during a MySQL performance problem.
# Typically executed from the 'stalk' program.
#
# Author: Baron Schwartz
# ########################################################################

# Print a usage message and exit.
usage() {
   if [ "${OPT_ERR}" ]; then
      echo "${OPT_ERR}"
   fi
   cat <<-USAGE
Usage: $0 OPTIONS [MYSQL-OPTIONS]
   Collects diagnostic data on a MySQL server and stores it into files.
   The MYSQL-OPTIONS are standard options to connect to MySQL: -uhPpS. Any
   options or arguments that follow this tool's -digos options will be treated
   as options to pass directly to mysql and mysqladmin.
Options: (required: -digos)
   -d DESTINATION Where to store the resulting data.
   -i INTERVAL    How many seconds to collect data.
   -g <yes/no>    Collect GDB stack traces.
   -o <yes/no>    Collect oprofile data.
   -s <yes/no>    Collect strace data.
	USAGE
   exit 1
}


for o; do
   case "${o}" in
      --)
         shift; break;
         ;;
      --help)
         usage;
         ;;
      -d)
         shift; OPT_d="${1}"; shift;
         ;;
      -i)
         shift; OPT_i="${1}"; shift;
         ;;
      -g)
         shift; OPT_g="${1}"; shift;
         ;;
      -o)
         shift; OPT_o="${1}"; shift;
         ;;
      -s)
         shift; OPT_s="${1}"; shift;
         ;;
   esac
done

if [ -z "${OPT_d}" -o -z "${OPT_i}" -o -z "${OPT_o}" -o -z "${OPT_g}"  -o -z "${OPT_s}" ]; then
   OPT_ERR="Missing command-line option."
   usage
fi

# Make sure there's only one of me.
(
   flock -x -s 200

   d=$(date +%F-%T | tr :- _);
   echo "Gathering info for $d"
   # Get pidof mysqld; pidof doesn't exist on some systems.  We try our best...
   p=$(pidof -s mysqld 2>/dev/null);
   if [ -z "${p}" ]; then
      p=$(pgrep -o -x mysqld 2>/dev/null)
   fi
   if [ -z "${p}" ]; then
      p=$(ps -eaf | grep 'mysql[d]' | grep -v mysqld_safe | awk '{print $2}' | head -n1);
   fi

   # Getting a GDB stacktrace can be an intensive operation, so do this only if
   # necessary.
   if [ "${OPT_g}" = "yes" -a "${p}" ]; then
      gdb -ex "set pagination 0" -ex "thread apply all bt" --batch -p $p >> $OPT_d/$d-stacktrace
   else
      echo "GDB (-g) was not enabled" >> $OPT_d/$d-stacktrace
   fi

   # Get a sample of SHOW INNODB STATUS and SHOW FULL PROCESSLIST right away, so
   # we can get these without interaction with the other commands we're about to
   # run.
   INNOSTAT="SHOW /*!40100 ENGINE*/ INNODB STATUS\G"
   mysql $@ -e 'SHOW GLOBAL VARIABLES'   >> $OPT_d/$d-variables 2>&1 &
   mysql $@ -e "${INNOSTAT}"             >> $OPT_d/$d-innodbstatus1 2>&1 &
   mysql $@ -e 'SHOW FULL PROCESSLIST\G' >> $OPT_d/$d-processlist1  2>&1 &

   # Next, start oprofile gathering data during the whole rest of this process.
   # The --init should be a no-op if it has already been init-ed.
   if [ "${OPT_o}" = "yes" ]; then
      if opcontrol --init >/dev/null 2>&1; then
         opcontrol --start --no-vmlinux
      else
         OPT_o="no"
      fi
   elif [ "${OPT_s}" = "yes" ]; then
      # Don't run oprofile and strace at the same time.
      strace -T -s 0 -f -p $p > "${DEST}/$d-strace" 2>&1 &
      strace_pid=$!
   fi

   # Grab a few general things first.  Background all of these so we can start
   # them all up as quickly as possible.
   ps -eaf                       >> $OPT_d/$d-ps 2>&1 &
   top -bn1                      >> $OPT_d/$d-top 2>&1 &
   vmstat 1 $OPT_i               >> $OPT_d/$d-vmstat 2>&1 &
   vmstat $OPT_i 2               >> $OPT_d/$d-vmstat-overall 2>&1 &
   iostat -dxn 1 $OPT_i          >> $OPT_d/$d-iostat 2>&1 &
   iostat -dxn $OPT_i 2          >> $OPT_d/$d-iostat-overall 2>&1 &
   mpstat -P ALL 1 $OPT_i        >> $OPT_d/$d-mpstat 2>&1 &
   mpstat -P ALL $OPT_i 1        >> $OPT_d/$d-mpstat-overall 2>&1 &
   lsof -nP -p $p -bw            >> $OPT_d/$d-lsof 2>&1 &
   mysqladmin $@ ext -i1 -c$OPT_i  >> $OPT_d/$d-mysqladmin 2>&1 &
   mysqladmin_pid=$!

   # This loop is a bit redundant to the rest of the stuff, but in some cases we
   # really need this data, like diskstats.  This loop also defines the time of
   # the whole job.  Nanosecond precision isn't possible, but we can surely do
   # better than 1-second.
   for a in `seq 1 $OPT_i`; do
      ts=$(date +%s.%N);
      echo "TS $ts" >> $OPT_d/$d-diskstats; cat /proc/diskstats >> $OPT_d/$d-diskstats 2>&1 &
      echo "TS $ts" >> $OPT_d/$d-procstat;  cat /proc/stat      >> $OPT_d/$d-procstat 2>&1 &
      echo "TS $ts" >> $OPT_d/$d-df;        df -h               >> $OPT_d/$d-df 2>&1 &
      echo "TS $ts" >> $OPT_d/$d-netstat;   netstat -antp       >> $OPT_d/$d-netstat 2>&1 &
      echo "TS $ts" >> $OPT_d/$d-netstat_s; netstat -s          >> $OPT_d/$d-netstat_s 2>&1 &
      sleep 1
   done
   # Tools to work with the data collected above will rely on <data><timestamp>
   # formatting.
   ts=$(date +%s.%N);
   echo "TS $ts" >> $OPT_d/$d-diskstats;
   echo "TS $ts" >> $OPT_d/$d-procstat;
   echo "TS $ts" >> $OPT_d/$d-df;
   echo "TS $ts" >> $OPT_d/$d-netstat;

   if [ "${OPT_o}" = "yes" ]; then
      opcontrol --stop;
      opcontrol --dump;
      kill $(pidof oprofiled 2>/dev/null) 2>/dev/null;
      opcontrol --save=$d;
      echo "oprofile data saved to $d; you should now be able to get a  report"
      echo "by running something like"
      echo "opreport --demangle=smart --symbols --merge tgid session:$d <bin>"
   elif [ "${OPT_s}" = "yes" ]; then
      kill -s 2 ${strace_pid}
      sleep 1
      kill -s 15 ${strace_pid} 2>/dev/null
      # Sometimes strace leaves threads/processes in T status.
      kill -s 18 $p
   fi

   mysql $@ -e "${INNOSTAT}"             >> $OPT_d/$d-innodbstatus2 2>&1 &
   mysql $@ -e 'SHOW FULL PROCESSLIST\G' >> $OPT_d/$d-processlist2  2>&1 &

   # mysqladmin in 5.1 has a bunch of obnoxious bugs.  Among them, -c does not
   # work, so it will continue forever unless we kill it.
   kill $mysqladmin_pid 2>/dev/null;
)200>/tmp/aspersa-collect-lockfile
