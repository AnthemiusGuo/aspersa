#!/usr/bin/env bash
# This program is part of Aspersa (http://code.google.com/p/aspersa/)

# ########################################################################
# This script uses strace and lsof to watch a process's IO and print out a table
# of files and I/O activity.
# TODO Make a table of file descriptor, read/pread/write/pwrite/open/close, and the
# count and time and size of each operation in the cells of the table.  At the
# far right, print the filename and size of the file.
# TODO: also permit aggregating by thread ID instead of filename
# TODO: -t should make it print total size in MB and total time in S
# TODO: optionally aggregate by device, not by filename
# lsof -s -p $(pidof mysqld) > files;
# strace -f -e read,write,pread,pwrite,open -p 2362 -T -xx -s 0 > strace 2>&1
# grep -o 'pread([0-9]*' strace | cut -d'(' -f2 | sort |uniq -c | sort -rn
# grep 7792uW files
#
# Author: Baron Schwartz
# ########################################################################

# ########################################################################
# Variables that are used/reused in the awk code.
# ########################################################################
count_stats="
            if ( funcn == \"read\" ) {
               count_read[filename]++;
               sizes_read[filename] += size;
               times_read[filename] += timing;
            }
            else if ( funcn == \"pread\" ) {
               count_pread[filename]++;
               sizes_pread[filename] += size;
               times_pread[filename] += timing;
            }
            else if ( funcn == \"write\" ) {
               count_write[filename]++;
               sizes_write[filename] += size;
               times_write[filename] += timing;
            }
            else if ( funcn == \"pwrite\" ) {
               count_pwrite[filename]++;
               sizes_pwrite[filename] += size;
               times_pwrite[filename] += timing;
            }
            else if ( funcn == \"open\" ) {
               count_open[filename]++;
               sizes_open[filename] += size;
               times_open[filename] += timing;
            }"

# ########################################################################
# Variables that are set by command-line options and/or the interactive
# functionality, and are used in the various snippets below
# ########################################################################

# Read the 'lsof' and 'strace' from the file, summarize, print.
summarize_strace() {
   cat > /tmp/aspersa.awk <<EOF
   /^COMMAND/ {
      # The lsof output is beginning.
      lsof = 1;
   }
   /^Process/ {
      # lsof has ended, strace output begins.
      lsof   = 0;
      strace = 1;
   }
   {
      if ( lsof == 1 && \$5 == "REG" ) {
         # Save the file descriptor and name for lookup later.
         fd=\$4;
         gsub(/[rwu-].*/, "", fd);
         filename_for[fd] = \$9;
         filenames[\$9]++;
      }
      else if ( strace == 1 && \$1 ~ /^\[/ ) {

         # Function calls
         if ( \$3 !~ /^</ ) {
            pid   = \$2;
            funcn = substr(\$3, 1, index(\$3, "(") - 1);
            fd    = substr(\$3, index(\$3, "(") + 1);
            fd    = substr(fd, 1, index(fd, ",") - 1);
            # handle unfinished calls
            if ( \$NF ~ />/ ) {
               unfinished[pid funcn] = fd;
            }
            else {
               filename = filename_for[fd];
               if ( filename != "" ) {
                  size_field = NF - 1;
                  size       = \$size_field;
                  timing     = \$NF;
                  gsub(/[<>]/, "", timing);
                  ${count_stats}
               }
            }
         }

         # Continuation of a previously <unfinished ...> function call
         else {
            pid        = \$2;
            funcn      = \$4;
            fd         = unfinished[pid funcn];
            if ( fd > 0 ) {
               filename = filename_for[fd];
               if ( filename != "" ) {
                  size_field = NF - 1;
                  size       = \$size_field;
                  timing     = \$NF;
                  gsub(/[<>]/, "", timing);
                  ${count_stats}
               }
            }
         }
      }
   }
   END {
      for (f in filenames) {
         preads       = 0;
         pread_avgtm  = 0;
         pread_avgsz  = 0;
         reads        = 0;
         read_avgtm   = 0;
         read_avgsz   = 0;
         pwrites      = 0;
         pwrite_avgtm = 0;
         pwrite_avgsz = 0;
         writes       = 0;
         write_avgtm  = 0;
         write_avgsz  = 0;
         opens        = 0;
         open_avgtm   = 0;
         open_avgsz   = 0;
         total_count  = 0;
         total_avgsz  = 0;
         total_avgtm  = 0;
         if ( count_pread[f] ) {
            preads      = count_pread[f];
            pread_avgtm = times_pread[f] / preads;
            pread_avgsz = sizes_pread[f] / preads;
         }
         if ( count_read[f] ) {
            reads      = count_read[f];
            read_avgtm = times_read[f] / reads;
            read_avgsz = sizes_read[f] / reads;
         }
         if ( count_pwrite[f] ) {
            pwrites      = count_pwrite[f];
            pwrite_avgtm = times_pwrite[f] / pwrites;
            pwrite_avgsz = sizes_pwrite[f] / pwrites;
         }
         if ( count_write[f] ) {
            writes      = count_write[f];
            write_avgtm = times_write[f] / writes;
            write_avgsz = sizes_write[f] / writes;
         }
         if ( count_open[f] ) {
            opens      = count_open[f];
            open_avgtm = times_open[f] / opens;
            open_avgsz = sizes_open[f] / opens;
         }
         total_count = preads + reads + pwrites + writes + opens;
         if ( total_count > 0 ) {
            total_avgsz = (sizes_pread[f] + sizes_read[f] + sizes_pwrite[f] + sizes_write[f] + sizes_open[f]) / total_count;
            total_avgtm = (times_pread[f] + times_read[f] + times_pwrite[f] + times_write[f] + times_open[f]) / total_count;
            printf("%4d %5.1f %7.3f %4d %5.1f %7.3f %4d %5.1f %7.3f %4d %5.1f %7.3f %4d %5.1f %7.3f %4d %5.1f %7.3f %s\\n",
               total_count, total_avgsz / 1024,   total_avgtm * 1000,
               preads,      pread_avgsz / 1024,   pread_avgtm * 1000,
               reads,       read_avgsz / 1024,    read_avgtm * 1000,
               pwrites,     pwrite_avgsz / 1024,  pwrite_avgtm * 1000,
               writes,      write_avgsz / 1024,   write_avgtm * 1000,
               opens,       open_avgsz / 1024,    open_avgtm * 1000,
               f);
         }
      }
   }
EOF

   for thing in TOT PRD RED PRW WRT OPN; do
      echo -n "N${thing} SZ${thing}   TM${thing} "
   done
   echo FILENAME
   awk -f /tmp/aspersa.awk $* | sort -rn -k1
   rm /tmp/aspersa.awk
}

# The main code that runs by default.  Arguments are the command-line options.
main() {
   summarize_strace $*
}

# Execute the program if it was not included from another file.  This makes it
# possible to include without executing, and thus test.
if [ $(basename "$0") = "ioprofile" ] || [ $(basename "$0") = "bash" -a "$_" = "$0" ]; then
    main $*
fi
