#!/usr/bin/env bash
# This program is part of Aspersa (http://code.google.com/p/aspersa/)

# ########################################################################
# This script uses strace and lsof to watch a process's IO and print out a table
# of files and I/O activity.
#
# Author: Baron Schwartz
# ########################################################################

# TODO: also permit aggregating by thread ID instead of filename
# TODO: -t should make it print total size in MB and total time in S
# TODO: optionally aggregate by device, not by filename

# Print a usage message and exit.
usage() {
   if [ "${OPT_ERR}" ]; then
      echo "${OPT_ERR}"
   fi
   echo "Usage: $0 -p <pid> -b <binary> -s <time> [FILE]"
   echo "   $0 does two things: 1) get lsof+strace for -s seconds and 2) aggregate it."
   echo "   If you specify -p, then -b is ignored.  Otherwise that binary is straced."
   echo "   If you specify a FILE, then step 1) above is not performed."
   exit 1
}

# ########################################################################
# Variables that are used/reused in the awk code.
# ########################################################################

wanted_pat="
      # These are function names, or partial function names, that we care about.
      # Later we will ignore any function whose name doesn't look like these.
      wanted_pat  = \"read|write|sync|open|close|getdents|seek\";"

print_strace_line="
                  filename = filename_for[fd];
                  if ( filename != \"\" ) {
                     if ( funcn ~ /open/ ) {
                        size = 0;
                     }
                     else {
                        size_field = NF - 1;
                        size       = \$size_field;
                     }
                     timing = \$NF;
                     gsub(/[<>]/, \"\", timing);
                     print pid, funcn, fd, size, timing, filename;
                  }"

# ########################################################################
# Variables that are set by command-line options and/or the interactive
# functionality, and are used in the various snippets below
# ########################################################################

# Read the 'lsof' and 'strace' from the file, and convert it into lines:
# pid function fd_no size timing filename
tabulate_strace() {
   cat > /tmp/aspersa.awk <<EOF
   BEGIN {
      ${wanted_pat}
      cwd    = ""; # The process's cwd to prepend to ./ filenames later.
      mode   = 0;  # Whether we're in the lsof or strace part of the input.
   }
   /^COMMAND/ { mode = "lsof";   }
   /^Process/ { mode = "strace"; }
   {
      # Save the file descriptor and name for lookup later.
      if ( mode == "lsof" ) {
         if ( \$5 == "REG" ) {
            fd = \$4;
            gsub(/[rwu-].*/, "", fd);
            filename_for[fd] = \$9;
         }
         else if ( \$5 == "DIR" && \$4 == "cwd" ) {
            cwd = \$NF;
         }
      }
      else if ( mode == "strace" && \$1 ~ /^\[/ ) {
         pid = substr(\$2, 1, length(\$2) - 1);

         # Continuation of a previously <unfinished ...> function call
         if ( \$3 == "<..." ) {
            funcn      = \$4;
            fd         = unfinished[pid "," funcn];
            if ( fd > 0 ) {
               ${print_strace_line}
            }
         }

         # The beginning of a function call (not resumed).  There are basically
         # two cases here: the whole call is on one line, and it's unfinished
         # and ends on a later line.
         else {
            funcn = substr(\$3, 1, index(\$3, "(") - 1);
            if ( funcn ~ wanted_pat ) {
               # Save the file descriptor and name for lookup later.
               if ( funcn ~ /open/ ) {
                  filename = substr(\$3, index(\$3, "(") + 2);
                  filename = substr(filename, 1, index(filename, "\\"") - 1);
                  if ( "./" == substr(filename, 1, 2) ) {
                     # Translate relative filenames into absolute ones.
                     filename = cwd substr(filename, 2);
                  }
                  fd_field         = NF - 1;
                  fd               = \$fd_field;
                  filename_for[fd] = filename;
               }

               else {
                  fd  = substr(\$3, index(\$3, "(") + 1);
                  fd  = substr(fd, 1, length(fd) - 1);
               }

               # Save unfinished calls for later
               if ( \$NF == "...>" ) {
                  unfinished[pid "," funcn] = fd;
               }

               # Function calls that are all on one line, not <unfinished ...>
               else {
                  ${print_strace_line}
               }
            }
         }

      }
   }
EOF
   awk -f /tmp/aspersa.awk $*
}

summarize_strace() {
   cat > /tmp/aspersa.awk <<EOF
   BEGIN {
      ${wanted_pat}
      wanted["1"] = "read"; # Will match pread, pread64, etc.
      wanted["2"] = "write";
      wanted["3"] = "sync";
      wanted["4"] = "open";
      wanted["5"] = "close";
      wanted["6"] = "getdents";
      wanted["7"] = "seek";
      num_wanted  = 7;
      col_pat     = "%10.6f ";
      hdr_pat     = "%10s ";
   }
   {
      if ( funcn ~ wanted_pat ) {
         filenames[filename]++;
         count[funcn "," filename]++;
         sizes[funcn "," filename] += size;
         times[funcn "," filename] += timing;
      }
   }
   END {
      # Choose which functions we want to print out, ordered by wanted[].
      num_functions = 0;
      printf(hdr_pat, "total");
      for (i = 1; i <= num_wanted; i++) {
         for (funcn in func_names) {
            if ( funcn ~ wanted_pat && !accepted[funcn] ) {
               num_functions++;
               funcs_to_print[num_functions] = funcn;
               accepted[funcn]++;
               printf(hdr_pat, funcn);
            }
         }
      }
      print "filename";
      # filenames[] contains only files that have been referenced by some
      # functions, so we are automatically including only files that have some
      # activity from wanted functions.
      for (filename in filenames) {
         total_count = 0;
         total_size  = 0;
         total_time  = 0;
         output      = "";
         for (i = 1; i <= num_functions; i++) {
            funcn = funcs_to_print[i];
            total_count += count[funcn "," filename];
            total_size  += sizes[funcn "," filename];
            total_time  += times[funcn "," filename];
            output = output sprintf(col_pat, times[funcn "," filename]);
         }
         printf(col_pat "%s%s\\n", total_time, output, filename);
      }
   }
EOF

   awk -f /tmp/aspersa.awk $* > /tmp/aspersa2
   head -n1 /tmp/aspersa2
   tail -n +2 /tmp/aspersa2 | sort -rn -k1
}

# The main code that runs by default.  Arguments are the command-line options.
main() {
   rm -f /tmp/aspersa{,.awk,2}

   # Get command-line options.
   for o; do
      case "${o}" in
         --)
            break;
            ;;
         -p)
            shift; pid="${1}"; shift;
            ;;
         -b)
            shift; binary="${1}"; shift;
            ;;
         -s)
            shift; stime="${1}"; shift;
            ;;
         -*)
            OPT_ERR="Unknown option '${o}'."
               usage 1
            ;;
      esac
   done
   if [ "${OPT_ERR}" ]; then
      usage
   fi

   if [ -z "${1}" ]; then
      # There's no file to analyze, so we'll make one.
      stime=${stime:-0}
      binary=${binary:-mysqld}
      if [ -z "${pid}" ]; then
         pid=$(pidof -s "${binary}" 2>/dev/null);
         if [ -z "${pid}" ]; then
            pid=$(ps -eaf | grep "${binary}" | grep -v grep | awk '{print $2}' | head -n1);
         fi
      fi
      date;
      if [ "${pid}" ]; then
         lsof -s -p "${pid}" > /tmp/aspersa
         strace -T -s 0 -f -e trace=file -e trace=desc -p ${pid} >> /tmp/aspersa 2>&1
      else
         echo "No such process"
         exit 1
      fi
   fi

   summarize_strace "${1:-/tmp/aspersa}"
   rm -f /tmp/aspersa{,.awk,2}
}

# Execute the program if it was not included from another file.  This makes it
# possible to include without executing, and thus test.
if [ $(basename "$0") = "ioprofile" ] || [ $(basename "$0") = "bash" -a "$_" = "$0" ]; then
    main $*
fi
