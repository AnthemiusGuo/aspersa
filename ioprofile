#!/usr/bin/env bash
# This program is part of Aspersa (http://code.google.com/p/aspersa/)

# ########################################################################
# This script uses strace and lsof to watch a process's IO and print out a table
# of files and I/O activity.
#
# Author: Baron Schwartz
# ########################################################################

# TODO: also permit aggregating by thread ID instead of filename
# TODO: -t should make it print total size in MB and total time in S
# TODO: optionally aggregate by device, not by filename

# Print a usage message and exit.
usage() {
   if [ "${OPT_ERR}" ]; then
      echo "${OPT_ERR}"
   fi
   echo "Usage: $0 -p <pid> -b <binary> -s <time> [FILE]"
   echo "   $0 does two things: 1) get lsof+strace for -s seconds and 2) aggregate it."
   echo "   If you specify -p, then -b is ignored.  Otherwise that binary is straced."
   echo "   If you specify a FILE, then step 1) above is not performed."
   exit 1
}

# ########################################################################
# Variables that are used/reused in the awk code.
# ########################################################################
count_stats="
               if ( funcn ~ wanted_pat ) {
                  filenames[filename]++;
                  count[funcn \",\" filename]++;
                  sizes[funcn \",\" filename] += size;
                  times[funcn \",\" filename] += timing;
               }"

# ########################################################################
# Variables that are set by command-line options and/or the interactive
# functionality, and are used in the various snippets below
# ########################################################################

# Read the 'lsof' and 'strace' from the file, summarize, print.
summarize_strace() {
   cat > /tmp/aspersa.awk <<EOF
   BEGIN {
      # These are function names, or partial function names, that we care about.
      # Later we will ignore any function whose name doesn't look like these.
      wanted["1"] = "read"; # Will match pread, pread64, etc.
      wanted["2"] = "write";
      wanted["3"] = "sync";
      wanted["4"] = "open";
      wanted["5"] = "close";
      wanted_pat  = "read|write|sync|open|close";
      num_wanted  = 5;
   }
   /^COMMAND/ {
      # The lsof output is beginning.
      lsof = 1;
   }
   /^Process/ {
      # lsof has ended, strace output begins.
      lsof   = 0;
      strace = 1;
   }
   {
      if ( lsof == 1 && \$5 == "REG" ) {
         # Save the file descriptor and name for lookup later.
         fd = \$4;
         gsub(/[rwu-].*/, "", fd);
         filename_for[fd] = \$9;
      }
      else if ( strace == 1 && \$1 ~ /^\[/ ) {

         # Function calls
         if ( \$3 !~ /^</ ) {
            pid   = \$2;
            funcn = substr(\$3, 1, index(\$3, "(") - 1);
            fd    = substr(\$3, index(\$3, "(") + 1);
            fd    = substr(fd, 1, index(fd, ",") - 1);
            func_names[funcn]++;
            # handle unfinished calls
            if ( \$NF ~ />/ ) {
               unfinished[pid funcn] = fd;
            }
            else {
               filename = filename_for[fd];
               if ( filename != "" ) {
                  size_field = NF - 1;
                  size       = \$size_field;
                  timing     = \$NF;
                  gsub(/[<>]/, "", timing);
                  ${count_stats}
               }
            }
         }

         # Continuation of a previously <unfinished ...> function call
         else {
            pid        = \$2;
            funcn      = \$4;
            fd         = unfinished[pid funcn];
            if ( fd > 0 ) {
               filename = filename_for[fd];
               if ( filename != "" ) {
                  size_field = NF - 1;
                  size       = \$size_field;
                  timing     = \$NF;
                  gsub(/[<>]/, "", timing);
                  ${count_stats}
               }
            }
         }
      }
   }
   END {
      # Choose which functions we want to print out, ordered by wanted[].
      num_functions = 0;
      printf("%9s ", "total");
      for (i = 1; i <= num_wanted; i++) {
         for (funcn in func_names) {
            if ( funcn ~ wanted_pat && !accepted[funcn] ) {
               num_functions++;
               funcs_to_print[num_functions] = funcn;
               accepted[funcn]++;
               printf("%9s ", funcn);
            }
         }
      }
      print "filename";
      # filenames[] contains only files that have been referenced by some
      # functions, so we are automatically including only files that have some
      # activity from wanted functions.
      for (filename in filenames) {
         total_count = 0;
         total_size  = 0;
         total_time  = 0;
         output      = "";
         for (i = 1; i <= num_functions; i++) {
            funcn = funcs_to_print[i];
            total_count += count[funcn "," filename];
            total_size  += sizes[funcn "," filename];
            total_time  += times[funcn "," filename];
            output = output sprintf("%9.6f ", times[funcn "," filename]);
         }
         printf("%9.6f %s%s\\n", total_time, output, filename);
      }
   }
EOF

   awk -f /tmp/aspersa.awk $* | sort -rn -k1
   rm /tmp/aspersa.awk
}

# The main code that runs by default.  Arguments are the command-line options.
main() {
   rm -f /tmp/aspersa

   # Get command-line options.
   for o; do
      case "${o}" in
         --)
            break;
            ;;
         -p)
            shift; pid="${1}"; shift;
            ;;
         -b)
            shift; binary="${1}"; shift;
            ;;
         -s)
            shift; stime="${1}"; shift;
            ;;
         -*)
            OPT_ERR="Unknown option '${o}'."
               usage 1
            ;;
      esac
   done
   if [ "${OPT_ERR}" ]; then
      usage
   fi

   if [ -z "${1}" ]; then
      # There's no file to analyze, so we'll make one.
      stime=${stime:-0}
      binary=${binary:-mysqld}
      if [ -z "${pid}" ]; then
         pid=$(pidof -s "${binary}" 2>/dev/null);
         if [ -z "${pid}" ]; then
            pid=$(ps -eaf | grep "${binary}" | grep -v grep | awk '{print $2}' | head -n1);
         fi
      fi
      date;
      if [ "${pid}" ]; then
         lsof -s -p "${pid}" > /tmp/aspersa
         strace -T -s 0 -f -e trace=file -e trace=desc -p ${pid} >> /tmp/aspersa 2>&1
      else
         echo "No such process"
         exit 1
      fi
   fi

   summarize_strace "${1:-/tmp/aspersa}"
   #rm -f /tmp/aspersa
}

# Execute the program if it was not included from another file.  This makes it
# possible to include without executing, and thus test.
if [ $(basename "$0") = "ioprofile" ] || [ $(basename "$0") = "bash" -a "$_" = "$0" ]; then
    main $*
fi
